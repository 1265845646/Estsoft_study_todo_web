# 📅 1/5 데이터베이스 설계 (PostgreSQL)

## 1. 설계의 출발점  
### “기능 구현”보다 “데이터 무결성”을 먼저 잡는다

이번 프로젝트에서 데이터베이스는 단순한 저장소가 아니라  
**사용자 데이터 분리, 무결성 강제, 삭제 정책, 조회 성능**을 책임지는  
서비스의 핵심 구조라고 판단했다.

따라서 

- 어떤 상황에서 데이터가 의도와 다르게 저장될 수 있는지  
- 그 책임을 애플리케이션 코드가 아닌 **DB 제약으로 이전할 수 있는지**  
- 사용자가 늘어났을 때 데이터 조회 패턴이 어떻게 되는지  

를 먼저 정리하고, 구조를 확정한 뒤 구현으로 들어가는 방식을 선택했다.

---

## 2. 핵심 요구사항을 DB 관점으로 재정의

### 2-1. 필수 구조 제약
- RDBMS: **PostgreSQL**
- User : Todo = **1:N**
- User : Category = **1:N**
- Todo는 날짜 기반 조회 가능해야 함 (`due_date`)
- Foreign Key 및 삭제 정책(ON DELETE) 명확히 정의
- 생성/수정 시간(`created_at`, `updated_at`) 기록 유지

### 2-2. 서비스 관점 제약
- 사용자별 데이터 완전 분리
- 카테고리 삭제 시 Todo 데이터 보존 정책 필요
- “오늘 / 이번주 / 미완료” 조회가 잦으므로 성능 설계 필요

---

## 3. 엔티티 도출 — 최소 구조 선택

요구사항 기준으로 독립 엔티티는 아래 3개로 확정했다.

1. **users** : 인증 + 모든 데이터 소유권 기준  
2. **categories** : 사용자별 분류 자원(Resource)  
3. **todos** : 서비스 핵심 데이터  

일정(Schedule) 테이블을 별도로 분리할지 고민했지만,  
현재 요구사항은 `due_date` 기반 필터(오늘/이번주/날짜별) 수준이므로  
**Schedule 테이블은 만들지 않고 todos에 통합**하기로 결정했다.

> 결론:  
> 현재 요구사항을 정확히 충족하는 **최소 구조**를 먼저 선택하고,  
> 확장 요구가 생기면 그때 구조를 분리한다.

---

## 4. 최종 스키마 설계 (PostgreSQL)


### users
- `email UNIQUE`  
  로그인 식별자이며, 중복 계정 생성 자체를 DB에서 차단
- `password`  
  원문 저장 금지, 해시 값만 저장
- `token_version`  
  JWT 기반 인증에서 이미 발급된 토큰을 무효화하기 위한 서버 제어 스위치

### categories
- 사용자별 관리 자원으로 분리
- `(user_id, name) UNIQUE`  
  사용자 단위에서 동일한 이름의 카테고리 중복 생성 방지
- `(user_id, id) UNIQUE`  
  todos 테이블에서 복합 FK를 걸기 위한 기반

### todos
- 서비스의 핵심 데이터이므로 카테고리 삭제 시에도 보존
- `category_id`는 NULL 허용 → 미분류 Todo 허용
- `is_completed`와 `completed_at`을 분리하여 상태와 기록을 구분

---

## 5. completed_at 컬럼을 둔 이유

`updated_at`은 제목 수정, 내용 수정, 카테고리 변경 등  
모든 수정 작업에서 갱신된다.

따라서 **완료 시점을 updated_at으로 판단하는 것은 데이터 정확성을 깨뜨린다**고
판단했다.

`completed_at`을 별도로 둠으로써:

- 실제 완료 시점을 정확히 기록할 수 있고
- “최근 완료”, “이번주 완료 통계” 같은 기능 확장이 가능하며
- 이후 생산성 리포트/통계 기능도 구조 변경 없이 대응할 수 있다.

---

## 6. 설계 포인트  
### “다른 사용자 카테고리 연결”을 DB에서 차단

단순히  
```sql
todos.category_id → categories.id
```
만 FK로 두면, 애플리케이션 코드에서 `user_id` 조건을 실수로 누락했을 때 다른 사용자의 카테고리를 연결해도 DB가 이를 막지 못한다.

이는 사용자 데이터 분리를 깨트릴 수 있는 구조적 위험이라고 판단하여 이를 방지하기 위해 아래와 같이 복합 외래키를 선택하였다. 

```sql
FOREIGN KEY (user_id, category_id)
REFERENCES categories(user_id, id)
```

- Todo는 반드시 **같은 `user_id`를 가진 category만 참조 가능**
- 다른 사용자 카테고리를 연결하려는 INSERT / UPDATE는 **DB에서 즉시 실패**

즉,  
> “개발자가 조심해야 하는 설계”가 아니라  
> **실수가 구조적으로 불가능한 설계**를 만든 것이다.

---

## 7. 삭제 정책(ON DELETE) 의사결정

### 7-1. 사용자 삭제 시
- `ON DELETE CASCADE`
- 사용자 없이 남는 Todo / Category는 의미가 없다고 판단

### 7-2. 카테고리 삭제 시

**후보 1: `ON DELETE CASCADE`**  
- 카테고리 삭제가 Todo 대량 삭제로 이어질 위험

**후보 2: `ON DELETE SET NULL` ✅ 최종 선택**

선택 이유:
- Todo는 사용자가 만든 **핵심 데이터** (보존 우선)
- Category는 **분류 수단** (없어져도 Todo는 남아야 함)

---

## 8. updated_at 관리 방식

애플리케이션 코드에서 매 UPDATE마다  
`updated_at = NOW()`를 직접 처리하면 누락 가능성이 존재한다.

그래서 다음 방식을 선택했다.

- 공통 함수 `set_updated_at()`
- 테이블별 `BEFORE UPDATE` 트리거

이를 통해 **DB 레벨에서 수정 시각을 일관되게 관리**하도록 했다.

---

## 9. 인덱스 설계 — 실제 조회 패턴 기준

Todo 서비스에서 반복 호출될 가능성이 높은 조회는 다음과 같다.

- 오늘 할 일
- 이번주 할 일
- 미완료 Todo

이에 맞춰 아래 인덱스를 설계했다.

```sql
(user_id, due_date)
(user_id, is_completed)
```

항상 `user_id`로 먼저 범위를 좁히고,  
그 다음 날짜 / 상태 조건을 적용하도록 설계했다.

---

## 10. 최종 결론

이번 데이터베이스 설계의 핵심은 한 문장으로 정리된다.

> **“기능 구현이 쉬운 구조가 아니라,  
> 잘못된 데이터가 들어갈 수 없는 구조를 먼저 만든다.”**

- 사용자 데이터 분리 → 복합 FK로 DB가 강제
- 삭제 정책 → Todo 보존 기준
- 일정 기능 → 요구사항 범위에서 `due_date`로 충분
- 수정 시각 → 트리거로 누락 없는 일관성 확보
- 성능 → 실제 조회 패턴 기준 인덱스 설계

이 설계는  
구현 편의보다 **무결성**을 우선했고,  
운영 리스크를 **DB 단계에서 차단**하며,  
확장 가능성을 구조로 열어둔 설계다.


