# 📅 1/6 인증·인가 설계 및 기능 구현 로그

## 1. 작업의 출발점  
### “DB 위에 바로 기능을 얹지 않는다”

1/5에 데이터베이스 설계를 마친 뒤,  
바로 기능(CRUD)을 붙이기보다는 **인증/인가 구조를 먼저** 작업했다.


- 다중 사용자 환경에서
- “기능이 되는지”보다
- **다른 사용자 데이터에 접근할 수 없는 구조인지**가 먼저 검증되어야 한다고 생각했기 때문이다.

그래서 1/6의 작업은  
**인증/인가 → 그 위에 최소 기능을 얹어 구조를 검증하는 단계**로 정의했다.

---

## 2. 인증 설계의 출발점 — 규모를 전제로 한 문제 인식

JWT 기반 인증은 구현이 간단하고 확장성이 좋아  
초기 서비스나 소규모 프로젝트에서는 충분히 합리적인 선택이다.

다만 이번 설계에서는 이 서비스를 
**많은 사용자가 동시에 이용하는 서비스**로 성장할 가능성을 전제로 두었다.

사용자가 늘어나고 서비스가 커지면, 단순히 “로그인/로그아웃이 된다”를 넘어서  
다음과 같은 상황들이 자연스럽게 발생할 수 있다고 가정해보았다.

- 비밀번호 변경
- 보안 이슈 대응
- 여러 기기에서의 동시 로그인 관리
- 특정 계정에 대한 전체 세션 종료 요구

이런 상황에서 JWT는 구조적으로  
**한 번 발급된 토큰을 서버가 즉시 통제하기 어렵다**는 특성이 있다.

토큰은 만료 시간 전까지 클라이언트가 소유하고 사용하기 때문에,  
서버 입장에서는 “지금 이 순간부터 이 계정의 인증을 끊어야 한다”는 요구를  
직접적으로 반영하기 어렵다.

이 점이 곧바로 문제가 된다고 보지는 않았지만,  
서비스가 커지고 **관리자 페이지·백오피스·계정 관리 기능**이 추가될 것을 고려했을 때  
초기 설계 단계에서 이 한계를 보완할 필요가 있다고 판단했다.

이 인식에서 인증/인가 구조 설계를 시작했고,  
그 결과로 3번에서 검토한 선택지들과 최종 구조가 도출되었다.

---

## 3. 검토한 선택지와 최종 판단

### 검토한 대안들

1. **Refresh Token만 Redis에서 관리**
   - 로그아웃 시 삭제 가능
   - ❌ 이미 발급된 Access Token은 즉시 무효화 불가

2. **Access Token 블랙리스트(JTI)**
   - 모든 요청마다 Redis 조회 필요
   - ❌ 관리 포인트가 많고 누락/버그 위험 큼

3. **Token Version 전략 (최종 선택)**
   - DB에 사용자별 token_version 관리
   - 토큰 payload에 version 포함
   - 불일치 시 즉시 무효화

### 최종 선택 이유
- 개념적으로 가장 명확
- 구현 단순
- **“계정 단위 Kill-Switch” 역할 가능**

---

## 4. `token_version` 설계 의도

`token_version`은  
JWT 기반 인증의 특성상 **서버가 즉각적으로 개입하기 어려운 부분을 보완하기 위해** 도입한 계정 단위 상태 값이다.

JWT의 장점을 유지하면서도,  
계정 상태 변화가 인증 판단에 자연스럽게 반영될 수 있는 구조를 만드는 것이 목표였다.


- 로그인 시, DB에 저장된 `token_version`을 토큰 payload에 포함
- 요청이 들어올 때, 서버가 가진 `token_version`과 토큰의 값을 비교
- 두 값이 일치하지 않으면 해당 토큰을 더 이상 유효하지 않은 것으로 판단하고 401 응답

이 구조를 통해 서버는  
토큰 자체를 직접 관리하지 않더라도, **계정 상태 변화만으로 인증을 제어할 수 있게 된다.**

그 결과:

- 비밀번호 변경이나 보안 이슈 발생 시 전체 기기 로그아웃 처리
- 특정 시점 이후 발급된 토큰만 유효하게 유지
- Refresh Token 탈취 상황에 대한 추가 방어 수단

이 모든 요구를  
**별도의 복잡한 관리 로직 없이, 단일 DB 컬럼 기준으로 일관되게 처리할 수 있는 구조**를 만들 수 있었다.

---

## 5. 성능 문제 인식과 Redis의 역할 재정의

인증 흐름에서는 모든 요청마다 JWT 검증과 `users.token_version` 조회가 발생한다.

사용자가 늘어날 경우 이 구조는 DB 부하와 병목 가능성으로 이어질 수 있다고 판단했다.

이를 완화하기 위해 Redis를 도입했지만, Redis를 인증 상태의 기준으로 사용하지는 않았다.


- **DB는 인증·보안 상태의 기준**
- **Redis는 조회 성능을 보완하는 캐시 계층**

Redis 장애가 발생하더라도 인증 판단 자체가 흔들리지 않도록,  
최종 판단은 항상 DB 기준으로 이루어지게 설계했다.

---

## 6. 최종 인증 구조 요약

- Refresh Token: Redis에 저장 (세션 통제)
- token_version:  
  - DB에 저장 (진짜 상태)
  - Redis에 캐싱 (성능)

인가 흐름:
1. Access Token 검증
2. Redis에서 token_version 조회
3. Cache Miss → DB 조회 후 Redis 재적재
4. version 비교
5. 불일치 시 즉시 차단

Redis 장애 시에도  
DB fallback으로 보안이 유지되는 구조를 선택했다.

---

## 7. 인증 이후, 


> “인가 구조가 실제 CRUD에서도 사용자 데이터 분리를 제대로 할 수 있는가?”

이를 검증하기 위해  
**가장 단순한 도메인부터 시작**하기로 했다.

- 사용자 단위 데이터 구조가 단순
- 인가 흐름 검증에 집중 가능
- 이후 Todos에서 category_id 연결이 자연스러울 것 같아서  

**Categories CRUD를 먼저 구현**해  인가 기반 CRUD 구조를 검증했다.

---

## 8. Categories / Todos 구현에서 지킨 원칙

### 공통 원칙
- 모든 API는 authMiddleware 아래에서 동작
- 컨트롤러에서는 항상 `req.user.userId` 기준으로 처리

### 구조적 안전장치
- 조회 / 수정 / 삭제 시
  - 항상 `WHERE id = ? AND user_id = ?`
- 인증이 끝났어도
  - **쿼리 레벨에서 한 번 더 사용자 범위 제한**

“컨트롤러에서 한 번, DB 쿼리에서 한 번”  
이중으로 안전장치를 두는 구조를 선택했다.

---

## 9. Todos 필터와 완료 토글 설계

Todo 서비스는 조회가 많다고 판단했기 때문에  
CRUD의 부가 기능이 아니라 **조회 자체를 핵심 기능**으로 봤다.

그래서:
- today / week / incomplete 필터를
- 프론트 가공이 아닌 **API 레벨에서 직접 지원**

완료 처리도:
- is_completed
- completed_at

을 함께 관리해 단순 상태 변경이 아니라 **의미 있는 기록**으로 남기도록 설계했다.

---

## 10. Postman을 ‘설계 검증’으로 사용

확인한 것:
- 인증 없으면 접근 불가
- 토큰 만료 시 동작
- 필터 조건 정확성
- 완료 토글 + 필터 연동

---

## 11. 1/6 작업의 결론

1/6의 작업은  

> **인증 → 인가 → CRUD → 프론트 호출 구조까지  
> 설계가 실제로 흔들리지 않는지 검증한 날**이었다.

- JWT의 한계를 이해하고 보완 구조를 선택했고
- 인가 기반 CRUD가 실제로 사용자 데이터를 분리하는지 확인했고
- 프론트 연동을 고려한 API 구조까지 미리 정리했다.

이 시점까지의 목표는  
**‘완성’이 아니라 ‘안전하게 다음 단계로 갈 수 있는 상태’**였다.
